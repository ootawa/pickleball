<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ピックルボールカウント</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin-top: 50px;
    }
    .counter {
      font-size: 5rem;
      margin: 20px 0;
      display: inline-block;
    }
    .button1 {
      font-size: 1rem;
      padding: 5px 5px;
      margin: 0px 3px;
      cursor: pointer;
    }
    .button2 {
      font-size: 2rem;
      padding: 10px 10px;
      margin: 0px 10px;
      cursor: pointer;
    }
  </style>
</head>
<body onload="myServReset();">
  <h1></h1>
  <button class="botton1" onclick="myServReset()">自分開始</button>
  <button class="botton1" onclick="oppServReset()">相手開始</button>
  <div style="align-items: center;">
    <div class="counter" id="mycount">0</div><div class="counter">-</div><div class="counter" id="oppcount">0</div><div class="counter">-</div><div class="counter" id="servcount">0</div>
  </div>
  <button class="botton2" onclick="myget()">&nbsp;&nbsp;&nbsp;&nbsp;自&nbsp;分&nbsp;&nbsp;&nbsp;&nbsp;</button>
  <button class="botton2"onclick="oppget()">&nbsp;&nbsp;&nbsp;&nbsp;相&nbsp;手&nbsp;&nbsp;&nbsp;&nbsp;</button>
  <div style="margin-top: 20px;">
    <button class="botton2" onclick="undo()">&nbsp;&nbsp;戻&nbsp;す&nbsp;&nbsp;</button>
  </div>

  <script>
    class Task {
      constructor(serviceSide, mycount, oppcount, servcount) {
        this.serviceSide = serviceSide;
        this.mycount = mycount;
        this.oppcount = oppcount;
        this.servcount = servcount;
      }
    }

    class TaskStack {
      constructor() {
        this.stack = [];
      }

      // スタックにタスクを追加
      push(task) {
        if (task instanceof Task) {
          this.stack.push(task);
        } else {
          throw new Error('Taskオブジェクトのみ追加できます');
        }
      }

      // スタックからタスクを取り出す
      pop() {
        return this.stack.pop();
      }

      // 最後のタスクを確認
      peek() {
        const last = this.stack[this.stack.length - 1];
        return new Task(last.serviceSide, last.mycount, last.oppcount, last.servcount);
      }

      // スタックが空かどうか
      isEmpty() {
        return this.stack.length === 0;
      }
    }
  
    let stack = new TaskStack();
    stack.push(new Task(1, 0, 0, 2));

    function updateCounter(obj) {
      document.getElementById('mycount').textContent = obj.mycount;
      document.getElementById('oppcount').textContent = obj.oppcount;
      document.getElementById('servcount').textContent = obj.servcount;
      if (obj.serviceSide == 1) {
        document.body.style.backgroundColor = "#AFEEEE";
      } else {
        document.body.style.backgroundColor = "#F08080";
      }
    }

    function myget() {
      let stack1 = stack.peek();
      // 自サーブで、自成功
      if (stack1.serviceSide == 1) {
        stack1.mycount++;
      }
      // 他サーブで、自成功
      if (stack1.serviceSide == 2) {
        if (stack1.servcount == 1) {
          // サービスカウントが1なら、他サーブのままサービスカウントをアップ
          stack1.servcount++;
        } else if (stack1.servcount == 2) {
          // サービスカウントが2なら、自サーブへ変更
          stack1.servcount = 1;
          stack1.serviceSide = 1;
        }
      }
      stack.push(stack1);
      updateCounter(stack1);
    }

    function oppget() {
      let stack1 = stack.peek();
      // 他サーブで、他成功
      if (stack1.serviceSide == 2) {
        stack1.oppcount++;
      }
      // 自サーブで、他成功
      if (stack1.serviceSide == 1) {
        if (stack1.servcount == 1) {
          // サービスカウントが1なら、自サーブのままサービスカウントをアップ
          stack1.servcount++;
        } else if (stack1.servcount == 2) {
          // サービスカウントが2なら、他サーブへ変更
          stack1.servcount = 1;
          stack1.serviceSide = 2;
        }
      }
      stack.push(stack1);
      updateCounter(stack1);
    }

    function myServReset() {
      stack = new TaskStack();
      let stack1 = new Task(1, 0, 0, 2)
      stack.push(stack1);
      updateCounter(stack1);
    }

    function oppServReset() {
      stack = new TaskStack();
      let stack1 = new Task(2, 0, 0, 2)
      stack.push(stack1);
      updateCounter(stack1);
    }

    function undo() {
      // 現在の状態を削除
      stack.pop();

      // スタックが空なら初期化
      if (stack.isEmpty()) {
        stack.push(new Task(1, 0, 0, 2)); // デフォルトは自分サーブ
      }

      // 最後の状態を取得して表示
      const lastState = stack.peek();
      updateCounter(lastState);
    }
  </script>
</body>
</html>
